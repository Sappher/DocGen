import path from 'path';

import * as core from '@actions/core';
import { context } from '@actions/github';

import { ActionInputs } from './types';

function coalesceInput(name: string, envName?: string): string {
  const actionValue = core.getInput(name);
  if (actionValue) {
    return actionValue.trim();
  }
  const envValue = process.env[envName ?? name.replace(/-/g, '_').toUpperCase()];
  return envValue ? envValue.trim() : '';
}

function coalesceBooleanInput(name: string, envName?: string, defaultValue = false): boolean {
  const actionProvided = core.getInput(name);
  if (actionProvided) {
    return /^true$/i.test(actionProvided.trim());
  }
  const envValue = process.env[envName ?? name.replace(/-/g, '_').toUpperCase()];
  if (envValue) {
    return /^true$/i.test(envValue.trim());
  }
  return defaultValue;
}

function parseNumber(value: string | undefined, fallback: number): number {
  if (!value) {
    return fallback;
  }
  const parsed = Number(value);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : fallback;
}

export function getActionInputs(): ActionInputs {
  const workspacePath = process.env.GITHUB_WORKSPACE ?? process.cwd();
  const promptsFolderInput = coalesceInput('prompts-folder', 'PROMPTS_FOLDER') || 'prompts';
  const outputFolderInput = coalesceInput('output-folder', 'OUTPUT_FOLDER') || 'generated-docs';

  const promptsFolder = path.resolve(workspacePath, promptsFolderInput);
  const outputFolder = path.resolve(workspacePath, outputFolderInput);

  const openaiApiKey =
    coalesceInput('openai-api-key', 'OPENAI_API_KEY') || process.env.OPENAI_API_KEY || '';
  if (!openaiApiKey) {
    throw new Error('Missing OpenAI API key. Provide it via the openai-api-key input or env.');
  }

  const githubToken =
    coalesceInput('github-token', 'GITHUB_TOKEN') || process.env.GITHUB_TOKEN || '';
  if (!githubToken) {
    throw new Error('Missing GitHub token. Provide it via the github-token input or env.');
  }

  const excludePatterns = core
    .getMultilineInput('exclude-patterns', { trimWhitespace: true })
    .filter(Boolean);

  if (!excludePatterns.length) {
    const envPatterns = process.env.EXCLUDE_PATTERNS;
    if (envPatterns) {
      excludePatterns.push(
        ...envPatterns
          .split(/\r?\n/) // newline separated
          .map((line) => line.trim())
          .filter(Boolean),
      );
    }
  }

  const maxFileSizeBytes = parseNumber(
    coalesceInput('max-file-size-bytes', 'MAX_FILE_SIZE_BYTES'),
    750_000,
  );

  const maxRepoCharacters = parseNumber(
    coalesceInput('max-repo-characters', 'MAX_REPO_CHARACTERS'),
    400_000,
  );

  const temperatureRaw = coalesceInput('temperature', 'OPENAI_TEMPERATURE');
  const parsedTemp = Number(temperatureRaw);
  const temperature = Number.isFinite(parsedTemp)
    ? Math.min(Math.max(parsedTemp, 0), 2)
    : 0;

  const model = coalesceInput('openai-model', 'OPENAI_MODEL') || 'gpt-4.1-mini';

  const branchNameInput = coalesceInput('branch-name', 'BRANCH_NAME');
  const runId = context.runId ?? Date.now();
  const runAttempt = context.runAttempt ?? 1;
  const defaultBranchName = `docgen/run-${runId}-${runAttempt}`;
  const branchName = branchNameInput || defaultBranchName;

  const baseBranch =
    coalesceInput('base-branch', 'BASE_BRANCH') || context.ref?.replace('refs/heads/', '') || 'main';

  const prTitle =
    coalesceInput('pr-title', 'PR_TITLE') || 'AI-generated documentation and analysis updates';
  const prBodyTemplate =
    coalesceInput('pr-body', 'PR_BODY') ||
    'Automated updates generated by the docgen action. Please review the changes.';

  const dryRun = coalesceBooleanInput('dry-run', 'DRY_RUN', false);

  const repoFullName = process.env.GITHUB_REPOSITORY ?? '';
  if (!repoFullName) {
    throw new Error('GITHUB_REPOSITORY env is required when running inside GitHub Actions.');
  }

  const [repositoryOwner, repositoryName] = repoFullName.split('/', 2);

  return {
    workspacePath,
    promptsFolder,
    outputFolder,
    promptsFolderInput,
    outputFolderInput,
    openaiModel: model,
    openaiApiKey,
    githubToken,
    excludePatterns,
    maxFileSizeBytes,
    maxRepoCharacters,
    temperature,
    branchName,
    baseBranch,
    prTitle,
    prBody: prBodyTemplate,
    dryRun,
    repoFullName,
    repositoryOwner,
    repositoryName,
    runId,
    runAttempt,
  };
}
